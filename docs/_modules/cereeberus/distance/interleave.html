

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cereeberus.distance.interleave &mdash; ceREEBerus 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ceREEBerus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Modules and Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">Tutorial Notebooks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ceREEBerus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">cereeberus.distance.interleave</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cereeberus.distance.interleave</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">cereeberus</span> <span class="kn">import</span> <span class="n">MapperGraph</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">..compute.unionfind</span> <span class="kn">import</span> <span class="n">UnionFind</span>
<span class="kn">from</span> <span class="nn">.labeled_blocks</span> <span class="kn">import</span> <span class="n">LabeledBlockMatrix</span> <span class="k">as</span> <span class="n">LBM</span>
<span class="kn">from</span> <span class="nn">.labeled_blocks</span> <span class="kn">import</span> <span class="n">LabeledMatrix</span> <span class="k">as</span> <span class="n">LM</span>
<span class="kn">from</span> <span class="nn">.ilp</span> <span class="kn">import</span> <span class="n">solve_ilp</span>
<span class="kn">from</span> <span class="nn">..compute.utils</span> <span class="kn">import</span> <span class="n">HiddenPrints</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>

<div class="viewcode-block" id="Interleave">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave">[docs]</a>
<span class="k">class</span> <span class="nc">Interleave</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to compute the interleaving distance between two Mapper graphs, denoted :math:`F` and :math:`G`. The interleaving distance is a measure of how similar two Mapper graphs are, based on the induced maps between them.</span>
<span class="sd">    </span>
<span class="sd">    Once the ``Interleave.fit()`` command has been run, the optimal bound for the distance for the input mapper graphs is stored as ``Interleave.n``. The resulting maps can be found using the ``Interleave.phi()`` and ``Interleave.psi()`` functions. For more detailed structure, the full interleaving is stored using an `Assignment` class, documented below, and can be accessed using ``Interleave.assignment``.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="Interleave.__init__">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Interleave object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            F (MapperGraph):</span>
<span class="sd">                The first Mapper graph.</span>
<span class="sd">            G (MapperGraph):</span>
<span class="sd">                The second Mapper graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span> <span class="o">=</span> <span class="n">G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="o">=</span> <span class="kc">None</span></div>

        
<div class="viewcode-block" id="Interleave.old_fit">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.old_fit">[docs]</a>
    <span class="k">def</span> <span class="nf">old_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pulp_solver</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_n_for_error</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> 
            <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the interleaving distance between the two Mapper graphs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            pulp_solver (pulp.LpSolver): </span>
<span class="sd">                The solver to use for the ILP optimization. If None, the default solver is used.</span>
<span class="sd">            verbose (bool, optional): </span>
<span class="sd">                If True, print the progress of the optimization. Defaults to False.</span>
<span class="sd">            max_n_for_error (int, optional): </span>
<span class="sd">                The maximum value of `n` to search for. If the interleaving distance is not found by this value, a ValueError is raised. Defaults to 100.</span>
<span class="sd">            printOptimizerOutput (bool, optional):</span>
<span class="sd">                If True, the output of the PULP optimizer is printed. Defaults to False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Interleave : </span>
<span class="sd">                The Interleave object with the computed interleaving distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># -- Search through possible n values to find the smallest one that still allows for interleaving</span>
        
        <span class="c1"># -- Dictionary to store the search data </span>
        <span class="c1"># -- This will store the Loss for each value of n so we don&#39;t </span>
        <span class="c1"># -- have to recompute it each time. </span>
        <span class="c1"># -- The distance bound can be determined by search_data[key] = Loss implies d_I &lt;= key + Loss</span>
        <span class="n">search_data</span> <span class="o">=</span> <span class="p">{}</span> 
        
        <span class="c1"># -- Set the initial value of the distance bound to be infinity</span>
        <span class="n">distance_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># -- Do an expoential search for the smallest n that allows for interleaving</span>
        <span class="c1"># -- Start with n = 1 and double it until the Loss is less than or equal to 0</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span> 
        <span class="n">found_max</span> <span class="o">=</span> <span class="kc">False</span>
            
        <span class="k">while</span> <span class="ow">not</span> <span class="n">found_max</span><span class="p">:</span>
            <span class="c1"># -- Compute the assignment for the current value of n</span>
            <span class="c1"># -- If the Loss is less than or equal to 0, we have found a valid n</span>
            <span class="c1"># -- Otherwise, double n and try again</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">Trying n = </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                <span class="n">myAssgn</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">N</span><span class="p">)</span>
                
                <span class="n">Loss</span> <span class="o">=</span> <span class="n">myAssgn</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
                <span class="n">search_data</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">Loss</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n = </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">, Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">, distance_bound = </span><span class="si">{</span><span class="n">N</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># -- If we get a ValueError, it means the current n is too small</span>
                <span class="c1"># -- So we double n and try again</span>
                <span class="n">search_data</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">Loss</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># -- If the Loss is less than or equal to 0, we have found a valid n</span>
                <span class="n">max_N</span> <span class="o">=</span> <span class="n">N</span>
                <span class="n">found_max</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found valid maximum n = </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> with Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">. Moving on to binary search.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># -- If the Loss is greater than 0, we need to try a larger n</span>
                <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span>
                
            <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="n">max_n_for_error</span><span class="p">:</span>
                <span class="c1"># -- If we have exceeded the maximum value of n, raise an error. Useful while we&#39;re checking this while loop</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interleaving distance not found for n &lt;= </span><span class="si">{</span><span class="n">max_n_for_error</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                
            

        <span class="c1"># now binary search in [0, max_N] to find the smallest n that gives a loss of 0</span>
        
        <span class="c1"># -- Set the initial values for the binary search</span>
        <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">max_N</span>
        <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">myAssgn</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mid</span><span class="p">)</span>
                <span class="n">Loss</span> <span class="o">=</span> <span class="n">myAssgn</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
                <span class="n">search_data</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">Loss</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># -- If we get a ValueError, it means the current n is too small</span>
                <span class="n">search_data</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">Loss</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># -- If the Loss is less than or equal to 0, we have found a valid n</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
                
        <span class="c1"># -- Set the final value of n to be the smallest one that gives a loss of 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">low</span>
        <span class="c1"># -- Set the assignment to be the one that minimizes the interleaving distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">Loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">,)</span>
        
        
        <span class="c1"># Raise error if the loss isn&#39;t 0 </span>
        <span class="k">if</span> <span class="n">Loss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final fit object is not an interleaving. Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">. N = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span></div>

    
<div class="viewcode-block" id="Interleave.fit">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pulp_solver</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">max_n_for_error</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the interleaving distance between the two Mapper graphs.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            pulp_solver (pulp.LpSolver): </span>
<span class="sd">                The solver to use for the ILP optimization. If None, the default solver is used.</span>
<span class="sd">            verbose (bool, optional): </span>
<span class="sd">                If True, print the progress of the optimization. Defaults to False.</span>
<span class="sd">            max_n_for_error (int, optional): </span>
<span class="sd">                The maximum value of `n` to search for. If the interleaving distance is not found by this value, a ValueError is raised. Defaults to 100. ####NOTE: this can be replaced by the bounding box.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            Int:</span>
<span class="sd">                The interleaving distance, that is, the smallest n for which loss is zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># step 0: search for n=0 </span>
        <span class="n">myAssgn</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Loss</span> <span class="o">=</span> <span class="n">myAssgn</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">Trying n = 0...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n = 0, Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">, distance_bound = </span><span class="si">{</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># if loss is 0, we&#39;re done</span>
        <span class="k">if</span> <span class="n">Loss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="o">=</span> <span class="n">myAssgn</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        
        <span class="c1"># step 1: exponential search for the upperbound</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">found_valid_n</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">while</span> <span class="n">high</span> <span class="o">&lt;=</span> <span class="n">max_n_for_error</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">myAssgn</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">high</span><span class="p">)</span>
                <span class="n">Loss</span> <span class="o">=</span> <span class="n">myAssgn</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">Trying n = </span><span class="si">{</span><span class="n">high</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n = </span><span class="si">{</span><span class="n">high</span><span class="si">}</span><span class="s2">, Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">, distance_bound = </span><span class="si">{</span><span class="n">high</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span>  <span class="n">Loss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">found_valid_n</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">,</span> <span class="n">high</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># infeasible assignment</span>
                <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">,</span> <span class="n">high</span><span class="o">*</span><span class="mi">2</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_valid_n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interleaving distance not found for n &lt;= </span><span class="si">{</span><span class="n">max_n_for_error</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        
        <span class="n">high</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">max_n_for_error</span><span class="p">)</span>  <span class="c1"># Clamp to max allowed</span>
        <span class="c1"># step 2: binary search for the optimal n</span>
        
        <span class="n">low</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">best_n</span> <span class="o">=</span> <span class="n">high</span>

        <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">:</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> 
            <span class="k">try</span><span class="p">:</span>
                <span class="n">myAssgn</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">mid</span><span class="p">)</span>
                <span class="n">Loss</span> <span class="o">=</span> <span class="n">myAssgn</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">-</span><span class="se">\n</span><span class="s2">Trying n = </span><span class="si">{</span><span class="n">mid</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n = </span><span class="si">{</span><span class="n">mid</span><span class="si">}</span><span class="s2">, Loss = </span><span class="si">{</span><span class="n">Loss</span><span class="si">}</span><span class="s2">, distance_bound = </span><span class="si">{</span><span class="n">mid</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">Loss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">best_n</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># decrease n to increase the loss</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="c1"># infeasible assignment</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>  
        
        <span class="c1"># validate the final solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">best_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="o">=</span> <span class="n">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="n">final_loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">final_loss</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected non-zero loss (Loss=</span><span class="si">{</span><span class="n">final_loss</span><span class="si">}</span><span class="s2">) for n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span></div>

            
    

<div class="viewcode-block" id="Interleave.phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.phi">[docs]</a>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`\\varphi: F \\to G^n` if ``key == &#39;0&#39;`` or :math:`\\varphi_n: F^n \\to G^{2n}` if ``key == &#39;n&#39;``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before getting the interleaving map.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Interleave.psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.psi">[docs]</a>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`\\psi: G \\to F^n` if ``key == &#39;0&#39;`` or :math:`\\psi_n: G^n \\to F^{2n}` if ``key == &#39;n&#39;``.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before getting the interleaving map.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Interleave.get_interleaving_map">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.get_interleaving_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_interleaving_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relevant interleaving map. Helpful for iterating over options. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either ``&#39;phi&#39;`` or ``&#39;psi&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The relevant interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before getting the interleaving map.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Interleave.draw_all_graphs">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_graphs">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw all the graphs stored in the Interleave object.</span>

<span class="sd">        Args:</span>
<span class="sd">            figsize (tuple, optional): Sets the size of the figure. Defaults to (15,10).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before drawing the graphs.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">draw_all_graphs</span><span class="p">()</span> </div>

    
<div class="viewcode-block" id="Interleave.draw_all_phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_phi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw all the phi maps stored in the Interleave object.</span>

<span class="sd">        Args:</span>
<span class="sd">            figsize (tuple, optional): Sets the size of the figure. Defaults to (15,10).</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the drawing function.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before drawing the phi maps.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">draw_all_phi</span><span class="p">(</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="Interleave.draw_all_psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_psi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw all the psi maps stored in the Interleave object.</span>

<span class="sd">        Args:</span>
<span class="sd">            figsize (tuple, optional): Sets the size of the figure. Defaults to (15,10).</span>
<span class="sd">            **kwargs: Additional keyword arguments to pass to the drawing function.</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You must call fit() before drawing the psi maps.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignment</span><span class="o">.</span><span class="n">draw_all_psi</span><span class="p">(</span><span class="n">figsize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    
    <span class="c1"># Disable Printing </span>
    <span class="k">def</span> <span class="nf">_blockPrint</span><span class="p">():</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">devnull</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

    <span class="c1"># Restore Printing</span>
    <span class="k">def</span> <span class="nf">_enablePrint</span><span class="p">():</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">__stdout__</span></div>

        

<span class="c1">#============================</span>
<span class="c1"># Assignment Class</span>
<span class="c1">#============================</span>

<div class="viewcode-block" id="Assignment">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment">[docs]</a>
<span class="k">class</span> <span class="nc">Assignment</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to determine the loss for a given assignment, and thus bound the interleaving distance between two Mapper graphs, denoted :math:`F` and :math:`G` throughout.</span>

<span class="sd">    We use keys ``[&#39;0&#39;, &#39;n&#39;, &#39;2n&#39;]`` to denote the Mapper graphs :math:`F = F_0`, :math:`F_n`, and :math:`F_{2n}` and similarly for :math:`G`.</span>

<span class="sd">    Note that the difference in the ranges of the two Mapper graphs must be within ``&#39;n&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Assignment.__init__">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> 
                        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
                        <span class="n">initialize_random_maps</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Interleave object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            F (MapperGraph):</span>
<span class="sd">                The first Mapper graph.</span>
<span class="sd">            G (MapperGraph):</span>
<span class="sd">                The second Mapper graph.</span>
<span class="sd">            n (int):</span>
<span class="sd">                The interleaving parameter. The default is 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

        <span class="c1"># --- Check that the ranges are compatible</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">min_f</span><span class="p">()</span><span class="o">-</span><span class="n">G</span><span class="o">.</span><span class="n">min_f</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max_f</span><span class="p">()</span><span class="o">-</span><span class="n">G</span><span class="o">.</span><span class="n">max_f</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function values for F and G are too far apart to interleave with n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">. Try initializing with a larger n.&quot;</span><span class="p">)</span>

        <span class="c1"># ---</span>
        <span class="c1"># Containers for matrices for later </span>

        <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># boundary matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># boundary matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># distance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># induced maps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># dictionaries from function values to vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># dictionaries from function values to edges</span>

        <span class="c1"># ----</span>
        <span class="c1"># Make F graphs and smoothed versions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">I_0_V</span><span class="p">,</span> <span class="n">I_0_E</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">smoothing_and_maps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> <span class="n">I_n_V</span><span class="p">,</span> <span class="n">I_n_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">smoothing_and_maps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        
        <span class="c1"># Get the dictionaries needed for the induced maps&#39; block structure </span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">func_to_vertex_dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">func_to_edge_dict</span><span class="p">()</span>

        
        <span class="c1"># Make the induced map from F_0 to F_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0_V</span><span class="p">,</span> 
                                     <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                     <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0_E</span><span class="p">,</span> 
                                     <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                     <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>

        <span class="c1"># Make the induced map from F_n to F_2n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_V</span><span class="p">,</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_E</span><span class="p">,</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>

        <span class="c1"># ----</span>
        <span class="c1"># Now do the same for G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">I_0_V</span><span class="p">,</span> <span class="n">I_0_E</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">smoothing_and_maps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> <span class="n">I_n_V</span><span class="p">,</span> <span class="n">I_n_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">smoothing_and_maps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># Get the dictionaries needed for the induced maps&#39; block structure </span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">func_to_vertex_dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">func_to_edge_dict</span><span class="p">()</span>

        <span class="c1"># Make the induced map from G_0 to G_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span> 
                                    <span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0_V</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0_E</span><span class="p">,</span> 
                                     <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                     <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_0_E</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>

        <span class="c1"># Make the induced map from G_n to G_2n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_V</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_E</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        
        <span class="c1"># End making smoothings and induced maps</span>
        <span class="c1"># ----</span>
        <span class="c1"># ---</span>
        <span class="c1"># Build boundary matrices </span>

        <span class="k">for</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]:</span> <span class="c1"># Note, we don&#39;t need to do this for 2n because the matrices are never used.</span>

                <span class="n">B_down</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>
                <span class="n">B_up</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">verts_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">verts_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">B_down</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">verts_down</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>
                        <span class="n">B_up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">verts_up</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                            <span class="n">B_down</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">B_up</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="n">max_i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

                <span class="n">min_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">min_i</span><span class="p">]</span>
                <span class="n">max_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">max_i</span><span class="p">]</span>

                <span class="n">B_up</span><span class="p">[</span><span class="n">min_i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">min_verts</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[])</span>
                <span class="n">B_down</span><span class="p">[</span><span class="n">max_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">max_verts</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_down</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_up</span>

        <span class="c1"># End boundary matrices</span>
        <span class="c1"># ---</span>

        <span class="c1"># ---</span>
        <span class="c1"># Build the distance matrices </span>
        <span class="k">for</span> <span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span> <span class="c1"># Note, we don&#39;t need to do this for 0 because the matrices are never used.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metagraph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">thickening_distance_matrix</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metagraph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">thickening_distance_matrix</span><span class="p">(</span><span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>

        <span class="c1"># End distance matrices</span>

        <span class="c1"># ----</span>
        <span class="c1"># phi: F -&gt; G^n</span>

        <span class="c1"># Initialize the phi matrices. These will have all 0 entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:{},</span> <span class="s1">&#39;n&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="c1"># End phi</span>
        <span class="c1"># ---</span>



        <span class="c1"># ----</span>
        <span class="c1"># psi: G -&gt; F^n</span>
        
        <span class="c1"># Initialize the psi matrices. These will have all 0 entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:{},</span> <span class="s1">&#39;n&#39;</span><span class="p">:{}}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span></div>

        

        <span class="c1"># End psi</span>
        <span class="c1"># ---</span>

 
        

    <span class="c1">### ----------------</span>
    <span class="c1"># Functions for getting stuff out of all the dictionaries </span>
    <span class="c1">### ----------------</span>

<div class="viewcode-block" id="Assignment.F">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.F">[docs]</a>
    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the MapperGraph for :math:`F` with key.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) :</span>
<span class="sd">                The key for the MapperGraph. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``. Default is ``&#39;0&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            MapperGraph : </span>
<span class="sd">                The MapperGraph for :math:`F` with key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="Assignment.G">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.G">[docs]</a>
    <span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the MapperGraph for :math:`G` with key.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the MapperGraph. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``. Default is ``&#39;0&#39;``.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            MapperGraph : </span>
<span class="sd">                The MapperGraph for :math:`G` with key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.B">[docs]</a>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is an endpoint of edge :math:`e` and 0 otherwise. Also, the boundary matrix is not computed for ``key = &#39;2n&#39;`` because it is not used in the optimization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The boundary matrix for the Mapper graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_labeled_matrix</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_labeled_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="Assignment.B_down">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.B_down">[docs]</a>
    <span class="k">def</span> <span class="nf">B_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the downward boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is a *lower* endpoint of edge :math:`e` and 0 otherwise. Also, the boundary matrix is not computed for ``key = &#39;2n&#39;`` because it is not used in the optimization.</span>


<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, or ``&#39;n&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The downward boundary matrix for the Mapper graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.B_up">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.B_up">[docs]</a>
    <span class="k">def</span> <span class="nf">B_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the upward boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is an *upper* endpoint of edge :math:`e` and 0 otherwise. Also, the boundary matrix is not computed for ``key = &#39;2n&#39;`` because it is not used in the optimization.</span>
<span class="sd">        </span>
<span class="sd">        If ``shift_indices`` is True, the indices of the matrix will be shifted (DOWN?) by one to make matrix multiplication work later.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;`` or  ``&#39;n&#39;``.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The upward boundary matrix for the Mapper graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.I">[docs]</a>
    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the induced map from one Mapper graph to another, specifically from ``graph_key`` to ``graph_(key+n)`` sending ``obj_type`` to the same type. For example, ``I(&#39;G&#39;, &#39;n&#39;, &#39;E&#39;)`` is the map for edges from :math:`G_n` to :math:`G_{2n}`.</span>
<span class="sd">        </span>
<span class="sd">        This is the matrix with entry :math:`I[u, v] = 1` if vertex :math:`v` in the first graph maps to vertex :math:`u` in the second graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the induced map for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the induced map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The induced map from ``graph_key`` to ``graph_(key+n)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>

        

<div class="viewcode-block" id="Assignment.D">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.D">[docs]</a>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the distance matrix for a Mapper graph. This is the matrix with entry :math:`D[u, v]` equal to the minimum thickening needed for vertices :math:`u` and :math:`v` to map to the same connected component (similarly for edges). Note this distance is only defined for vertices or edges at the same function value. Also, the distance matrix is not computed for key = &#39;0&#39; because it is not used in the optimization.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the distance matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the distance matrix. Either ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The distance matrix for the Mapper graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.phi">[docs]</a>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`\\varphi: F \\to G^n` if `key == &#39;0&#39;` or :math:`\\varphi_n: F^n \\to G^{2n}` if `key == &#39;n&#39;`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.psi">[docs]</a>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`\\psi: G \\to F^n` if `key == &#39;0&#39;` or :math:`\\psi_n: G^n \\to F^{2n}` if `key == &#39;n&#39;`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.get_interleaving_map">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.get_interleaving_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_interleaving_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relevant interleaving map. Helpful for iterating over options. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either ``&#39;phi&#39;`` or ``&#39;psi&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The relevant interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown maptype </span><span class="si">{</span><span class="n">maptype</span><span class="si">}</span><span class="s2">. Must be &#39;phi&#39; or &#39;psi&#39;.&quot;</span><span class="p">)</span></div>



    <span class="c1">### ----------------</span>
    <span class="c1"># Functions to set phi and psi matrices for the interleaving (instead of random)</span>
    <span class="c1">### ----------------</span>

<div class="viewcode-block" id="Assignment.set_interleaving_maps">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.set_interleaving_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">set_interleaving_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">psi_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the phi and psi matrices to a given value. Instead of replacing the matrices, set the values block by block.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            phi_dict (dict): </span>
<span class="sd">                A dictionary of the form ``{&#39;0&#39;: {&#39;V&#39;: phi_0_V, &#39;E&#39;: phi_0_E}, &#39;n&#39;: {&#39;V&#39;: phi_n_V, &#39;E&#39;: phi_n_E}}`` where each ``phi_i_j`` is a LabeledBlockMatrix.</span>
<span class="sd">            psi_dict (dict): </span>
<span class="sd">                A dictionary of the form ``{&#39;0&#39;: {&#39;V&#39;: psi_0_V, &#39;E&#39;: psi_0_E}, &#39;n&#39;: {&#39;V&#39;: psi_n_V, &#39;E&#39;: psi_n_E}}`` where each ``psi_i_j`` is a LabeledBlockMatrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">phi_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">thickening</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>

                    <span class="c1"># fist get the funciton values of the map that&#39;s coming in</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="n">phi_dict</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">get_all_block_indices</span><span class="p">()</span>

                    <span class="c1"># Now set the values</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi_dict</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">psi_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">thickening</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>

                    <span class="c1"># fist get the funciton values of the map that&#39;s coming in</span>
                    <span class="n">keys</span> <span class="o">=</span> <span class="n">psi_dict</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">get_all_block_indices</span><span class="p">()</span>

                    <span class="c1"># Now set the values</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">psi_dict</span><span class="p">[</span><span class="n">thickening</span><span class="p">][</span><span class="n">obj_type</span><span class="p">][</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Assignment.set_single_assignment">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.set_single_assignment">[docs]</a>
    <span class="k">def</span> <span class="nf">set_single_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj_a</span><span class="p">,</span> <span class="n">obj_b</span><span class="p">,</span> 
                              <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> 
                              <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> 
                              <span class="n">objtype</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single assignment in the interleaving map.</span>
<span class="sd">        </span>
<span class="sd">        This will be maptype_key(obj_a) = obj_b.</span>

<span class="sd">        Note that edges can be passed as a triple (u,v,count) where u and v are the vertices and count is the key for the edge. If passed as a pair, the count will be assumed to be 0.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            obj_a (int): Object in the domain of the map.</span>
<span class="sd">            obj_b (int): Object in the codomain of the map.</span>
<span class="sd">            maptype (str, optional): Map to be set, either &#39;phi&#39; or &#39;psi&#39;. Defaults to &#39;phi&#39;.</span>
<span class="sd">            objtype (str, optional): Type of object as input, either &#39;V&#39; or &#39;E&#39;. Defaults to &#39;V&#39;.</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="n">end_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">end_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;2n&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;key&#39; must be &#39;0&#39; or &#39;n&#39;.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                <span class="n">end_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">end_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;2n&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;key&#39; must be &#39;0&#39; or &#39;n&#39;.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;maptype&#39; must be &#39;phi&#39; or &#39;psi&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">objtype</span> <span class="o">==</span> <span class="s1">&#39;V&#39;</span><span class="p">:</span>
            <span class="c1"># Check that the objects have the same function value </span>
            <span class="k">if</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_b</span><span class="p">]:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">end_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_b</span><span class="p">]</span>
                <span class="n">end_graph</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The objects must have the same function value. </span><span class="si">{</span><span class="n">obj_a</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">obj_b</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">. Nodes: </span><span class="si">{</span><span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">end_graph</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">objtype</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">obj_a</span> <span class="o">=</span> <span class="n">obj_a</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edges must be passed as pairs or triples.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">obj_b</span> <span class="o">=</span> <span class="n">obj_b</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_b</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Edges must be passed as pairs or triples.&quot;</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">!=</span> <span class="n">end_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                
                <span class="n">i</span> <span class="o">=</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">end_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The objects must have the same function value. </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">start_graph</span><span class="o">.</span><span class="n">f</span><span class="p">[</span><span class="n">obj_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;objtype&#39; must be &#39;V&#39; or &#39;E&#39;.&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span> 
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj_b</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj_a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Maptype = &#39;psi&#39;</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj_b</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj_a</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">objtype</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span></div>

            
<div class="viewcode-block" id="Assignment.set_random_assignment">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.set_random_assignment">[docs]</a>
    <span class="k">def</span> <span class="nf">set_random_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_n</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the phi and psi matrices to random values. No matter what, the maps from F to Gn and G to Fn will be randomly set.  If ``&#39;random_n&#39;`` is True, the maps from Fn to G2n and Gn to F2n will also be randomly set. Otherwise, we will use matrix tricks to figure out the later from the former. </span>

<span class="sd">        Note this functions assumes the phi and psi dictionaries were set on initialization. It will overwrite any contents that are there. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----</span>
        <span class="c1"># phi: F -&gt; G^n</span>

        <span class="c1"># Set the phi matrices. These will have all random entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">random_n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">,</span>
                                    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">,</span>
                                    <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">to_indicator</span><span class="p">()</span>

        <span class="c1"># End phi</span>
        <span class="c1"># ---</span>

        <span class="c1"># ----</span>
        <span class="c1"># psi: G -&gt; F^n</span>

        <span class="c1"># Set the psi matrices. These will have all random entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">random_n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">to_indicator</span><span class="p">()</span></div>


        <span class="c1"># End psi</span>
        <span class="c1"># ---</span>


    <span class="c1">### ----------------</span>
    <span class="c1"># Functions for drawing stuff</span>
    <span class="c1">### ----------------</span>

<div class="viewcode-block" id="Assignment.draw_all_graphs">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_all_graphs">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draw all the graphs stored in the Interleave object.</span>

<span class="sd">        Args:</span>
<span class="sd">            figsize (tuple, optional): Sets the size of the figure. Defaults to (15,10).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_0$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_n$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;2n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_0$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_n$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="s1">&#39;2n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>


<div class="viewcode-block" id="Assignment.draw_I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_I">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the induced map from one Mapper graph to another.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the induced map for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the induced map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_n&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_2n&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Assignment.draw_all_I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_all_I">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span>  <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the induced maps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the induced maps for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            figsize (tuple) : </span>
<span class="sd">                The size of the figure. Default is (10,10).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Vertices: $&#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_0 \to &#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_</span><span class="si">{n}</span><span class="s1">$&#39;</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Edges: $&#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_0 \to &#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_</span><span class="si">{n}</span><span class="s1">$&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Vertices: $&#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_n \to &#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_</span><span class="si">{2n}</span><span class="s1">$&#39;</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>


        <span class="n">title</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;Edges: $&#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_n \to &#39;</span> <span class="o">+</span> <span class="n">graph</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;_</span><span class="si">{2n}</span><span class="s1">$&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>


<div class="viewcode-block" id="Assignment.draw_B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_B">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the boundary matrix for a Mapper graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;B(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;E(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Assignment.draw_all_B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_all_B">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">18</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the boundary matrices.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            figsize (tuple) : </span>
<span class="sd">                The size of the figure. Default is (24,18).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(F_0)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(F_n)$&#39;</span><span class="p">)</span>
        <span class="c1"># self.draw_B(&#39;F&#39;, &#39;2n&#39;, ax = axs[0, 2])</span>
        <span class="c1"># axs[0,2].set_title(r&#39;$B(F_{2n})$&#39;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(G_0)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(G_n)$&#39;</span><span class="p">)</span>
        <span class="c1"># self.draw_B(&#39;G&#39;, &#39;2n&#39;, ax = axs[1, 2])</span>
        <span class="c1"># axs[1,2].set_title(r&#39;$B(G_{2n})$&#39;)</span>
        
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>


<div class="viewcode-block" id="Assignment.draw_D">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_D">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                    <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the distance matrix for a Mapper graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the distance matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the distance matrix. Either  ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of matrix. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            colorbar (bool) : </span>
<span class="sd">                Whether to draw a colorbar. Default is True.</span>
<span class="sd">            ax ( matplotlib.axes.Axes) :</span>
<span class="sd">                The axes to draw the matrix on. If None, the current axes will be used.</span>
<span class="sd">            **kwargs (dict) : </span>
<span class="sd">                Additional keyword arguments to pass to the drawing function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="n">colorbar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Assignment.draw_phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_phi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the map :math:`\\psi: F \\to G^n`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_2n&#39;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">(G</span><span class="si">{</span><span class="n">F_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">(F</span><span class="si">{</span><span class="n">G_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

    
<div class="viewcode-block" id="Assignment.draw_psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_psi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the map :math:`\\psi: G \\to F^n`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">                </span>
<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_2n&#39;</span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">(G</span><span class="si">{</span><span class="n">G_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">(F</span><span class="si">{</span><span class="n">F_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Assignment.draw_all_phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_all_phi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the ``phi`` maps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            figsize (tuple) : </span>
<span class="sd">                The size of the figure. Default is (10,10).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_0^V$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_n^V$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_0^E$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_n^E$&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>


<div class="viewcode-block" id="Assignment.draw_all_psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.draw_all_psi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the ``psi`` maps.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            figsize (tuple) : </span>
<span class="sd">                The size of the figure. Default is (10,10).</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple: The figure and axes objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_0^V$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_n^V$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_0^E$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_n^E$&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span></div>


    <span class="c1"># =======================</span>
    <span class="c1"># Functions for checking commutative diagrams </span>
    <span class="c1"># =======================</span>

    <span class="k">def</span> <span class="nf">_draw_matrix_mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> 
                           <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span> 
                           <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A drawing function to check the matrix mutliplications for each of the three diagram types. </span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="n">figsize</span><span class="p">,</span> <span class="n">constrained_layout</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">LBM</span><span class="p">:</span>
            <span class="n">A</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filltype</span> <span class="o">=</span> <span class="s1">&#39;nan&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="n">LBM</span><span class="p">:</span>
            <span class="n">B</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filltype</span> <span class="o">=</span> <span class="s1">&#39;nan&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">==</span> <span class="n">LBM</span><span class="p">:</span>
            <span class="n">C</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filltype</span> <span class="o">=</span> <span class="s1">&#39;nan&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">C</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">D</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>  <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">titles</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span>

    <span class="c1">#---- Parallelogram: Edge-Vertex ----</span>

<div class="viewcode-block" id="Assignment.parallelogram_Edge_Vert_matrix">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.parallelogram_Edge_Vert_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram_Edge_Vert_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> 
                                <span class="n">up_or_down</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span><span class="p">,</span>
                                <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                                <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  
                                <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the parallelogram for the pair :math:`(S_{\\tau_i}\\subset S_{\\sigma_i})` commutes.</span>
<span class="sd">        This is the one that relates the edge maps to the vertex maps. Because a function value has both an up and down version, we need to specify which one we want to check with the ``up_or_down`` parameter.</span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map for the relevant diagram. Either ``&#39;phi&#39;`` or ``&#39;psi&#39;``.</span>
<span class="sd">            up_or_down (str) :</span>
<span class="sd">                Whether to check the up or down version of the parallelogram. Either ``&#39;up&#39;``, ``&#39;down&#39;``, or ``&#39;both&#39;``. Default is ``&#39;down&#39;``.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is ``False``.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickening required to make the diagram commute. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>
        
        <span class="k">if</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down</span>
            <span class="n">arrow</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">downarrow&#39;</span>
            <span class="n">interleaving_map_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span>
            <span class="n">interleaving_map_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up</span>
            <span class="n">arrow</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">uparrow&#39;</span>

            <span class="c1"># Shift of the top caused by indexing problem: </span>
            <span class="n">interleaving_map_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_shifted_blocks</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="n">interleaving_map_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">interleaving_map_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span>
            <span class="n">interleaving_map_bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>
            <span class="n">arrow</span> <span class="o">=</span> <span class="s1">&#39;{ }&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown up_or_down </span><span class="si">{</span><span class="n">up_or_down</span><span class="si">}</span><span class="s2">. Must be &#39;up&#39;, &#39;down&#39;, or &#39;both&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="n">interleaving_map_top</span> <span class="o">@</span> <span class="n">B</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="n">B</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="n">interleaving_map_bottom</span>

            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>

            <span class="k">if</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
                <span class="c1"># Need to undo the shift fix applied earlier</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">Result</span><span class="o">.</span><span class="n">to_shifted_blocks</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span> <span class="c1"># tau_i \to \sigma_i</span>
                <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
                <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>
            <span class="k">elif</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span> <span class="c1"># \tau_i \to \sigma_{i+1}</span>
                <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
                <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown up_or_down </span><span class="si">{</span><span class="n">up_or_down</span><span class="si">}</span><span class="s2">. Must be &#39;up&#39; or &#39;down&#39;.&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span> 
            <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$M_</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">^V </span><span class="se">\\</span><span class="s2">cdot B_</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">arrow</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$B_</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">arrow</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot M_</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">^E$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">^</span><span class="se">{{</span><span class="s2">n</span><span class="se">}}}}</span><span class="s2">^</span><span class="se">{{</span><span class="s2">V</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot  (</span><span class="si">{</span><span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_matrix_mult</span><span class="p">(</span><span class="n">Top</span><span class="p">,</span> <span class="n">Bottom</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Result_Dist</span><span class="p">,</span> <span class="n">titles</span> <span class="o">=</span> <span class="n">titles</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Result_Dist</span></div>


<div class="viewcode-block" id="Assignment.parallelogram_Edge_Vert">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.parallelogram_Edge_Vert">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram_Edge_Vert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> 
                                <span class="n">up_or_down</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span><span class="p">,</span>
                                <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the parallelogram for the pair :math:`(S_{\\tau_i}\\subset S_{\\sigma_i})` commutes, and return the maximum value in the matrix. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_Edge_Vert_matrix</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="n">up_or_down</span><span class="p">,</span> <span class="n">func_val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span></div>


    <span class="c1">#---</span>

    <span class="c1">#---- Parallelogram: Thickening ----</span>

<div class="viewcode-block" id="Assignment.parallelogram_matrix">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.parallelogram_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                            <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> 
                            <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                            <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                            <span class="p">):</span>
<span class="w">                            </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the paralellograms for checking that it&#39;s a nat trans.</span>
<span class="sd">        These are types 3-6 from Liz&#39;s Big List. </span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either &#39;phi&#39; or &#39;psi&#39;.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of object. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickening required to make the diagram commute. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            <span class="c1"># Result= Result.to_labeled_matrix() # To make the matrix labeledmatrix</span>
            
            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do this for a single input function value</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>

        <span class="c1"># --- Drawing--- #</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$M_</span><span class="se">{{</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">_n</span><span class="se">}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot I_</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$I_</span><span class="se">{{</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">^n</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot M_</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">^</span><span class="se">{{</span><span class="s2">2n</span><span class="se">}}}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot (</span><span class="si">{</span><span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>

            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_matrix_mult</span><span class="p">(</span><span class="n">Top</span><span class="p">,</span> <span class="n">Bottom</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Result_Dist</span><span class="p">,</span> <span class="n">titles</span> <span class="o">=</span> <span class="n">titles</span><span class="p">)</span>

            
        <span class="k">return</span> <span class="n">Result_Dist</span></div>


<div class="viewcode-block" id="Assignment.parallelogram">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.parallelogram">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span>
                        <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span>
                        <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the loss value for the thickening paralellograms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_matrix</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span><span class="p">)</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Result</span></div>


    <span class="c1"># --- Triangles ----</span>

<div class="viewcode-block" id="Assignment.triangle_matrix">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.triangle_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">triangle_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                        <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> 
                        <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                        <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the triangle for checking that it&#39;s an interleaving. </span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            start_graph (str) : </span>
<span class="sd">                The starting graph. Either &#39;F&#39; or &#39;G&#39;.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of object. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is False.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickenin grequired to make the diagram commute </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start_graph</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">map1</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span>
            <span class="n">map2</span> <span class="o">=</span> <span class="s1">&#39;psi&#39;</span>
            <span class="n">map1_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
            <span class="n">map2_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>
        <span class="k">elif</span> <span class="n">start_graph</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">map1</span> <span class="o">=</span> <span class="s1">&#39;psi&#39;</span>
            <span class="n">map2</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span>
            <span class="n">map1_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>
            <span class="n">map2_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown start_graph </span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">. Must be &#39;F&#39; or &#39;G&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            <span class="c1"># Result = Result.to_labeled_matrix() # To make the matrix labeledmatrix</span>

            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            
            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>

        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$I_</span><span class="se">{{</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">^n</span><span class="se">}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot I_</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$M_</span><span class="se">{{</span><span class="si">{</span><span class="n">map2_latex</span><span class="si">}</span><span class="s2">^n</span><span class="se">}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot M_</span><span class="se">{{</span><span class="si">{</span><span class="n">map1_latex</span><span class="si">}</span><span class="se">}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">titles</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">titles</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">^</span><span class="se">{{</span><span class="s2">2n</span><span class="se">}}}}</span><span class="s2">^</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot (</span><span class="si">{</span><span class="n">titles</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_matrix_mult</span><span class="p">(</span><span class="n">Top</span><span class="p">,</span> <span class="n">Bottom</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Result_Dist</span><span class="p">,</span> <span class="n">titles</span> <span class="o">=</span> <span class="n">titles</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Result_Dist</span></div>

    
<div class="viewcode-block" id="Assignment.triangle">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.triangle">[docs]</a>
    <span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the loss value for the triangle</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle_matrix</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span><span class="p">)</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
        <span class="n">Result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Result</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Result</span></div>


    <span class="c1"># --- Loss functions ----</span>

<div class="viewcode-block" id="Assignment.loss_table">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.loss_table">[docs]</a>
    <span class="k">def</span> <span class="nf">loss_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a table with the loss for each term in the bound. The actual loss is the maximum of these values, and can be found with the ``loss`` method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame : </span>
<span class="sd">                A table with the loss value for each term. The &#39;Loss&#39; column has the loss value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># All the edge-vertex parallelogram maps </span>
        <span class="k">for</span> <span class="n">maptype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">up_or_down</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_Edge_Vert</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">up_or_down</span> <span class="o">=</span> <span class="n">up_or_down</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;Edge-Vertex&#39;</span><span class="p">,</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">up_or_down</span><span class="p">,</span> <span class="n">loss</span><span class="p">])</span>

        <span class="c1"># All the parallelogram maps </span>
        <span class="k">for</span> <span class="n">maptype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;Thickening&#39;</span><span class="p">,</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">loss</span><span class="p">])</span>

        <span class="c1"># ALl the triangle maps</span>
        <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">start_graph</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="n">start_graph</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span>
                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;Triangle&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">start_graph</span><span class="p">,</span> <span class="n">loss</span><span class="p">])</span>
        <span class="n">loss_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">loss_list</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Dgm Type&#39;</span><span class="p">,</span> <span class="s1">&#39;Req A&#39;</span><span class="p">,</span> <span class="s1">&#39;Req B&#39;</span><span class="p">,</span> <span class="s1">&#39;Loss&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">loss_table</span></div>


<div class="viewcode-block" id="Assignment.loss">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.loss">[docs]</a>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the loss for the interleaving distance. Specifically, if the loss is :math:`L` and the interleaving class was initiated with :math:`n`, then the interleaving distance is at most :math:`n + L`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float : </span>
<span class="sd">                The loss value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loss_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_table</span><span class="p">()</span>
        
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_table</span><span class="p">[</span><span class="s1">&#39;Loss&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> 
            <span class="nb">print</span><span class="p">(</span><span class="n">loss_table</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Loss: </span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Interleaving distance bound: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">loss</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loss</span></div>


<div class="viewcode-block" id="Assignment.loss_by_block">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.loss_by_block">[docs]</a>
    <span class="k">def</span> <span class="nf">loss_by_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the loss for each block of the interleaving distance. </span>

<span class="sd">        Returns:</span>
<span class="sd">            dict : </span>
<span class="sd">                A dictionary with the loss for each block.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This is not at all done yet, consider this a placeholder!</span>
        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> 
        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_func_vals</span><span class="p">)</span>
        <span class="n">all_func_vals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">loss_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_func_vals</span><span class="p">:</span>
            <span class="c1">#====</span>
            <span class="c1"># Check the matrices with F(\sigma_i) or G(\sigma_i) in the top left </span>
            <span class="c1">#====</span>
            <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># -- Type 3, 5. Vertex type parallelogram </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">():</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="c1"># loss = result.absmax() </span>
                    <span class="c1"># print(f&quot;parallelogram loss for {graph_name} {obj_type} {i} is {loss}&quot;)</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span> 

            <span class="c1"># -- Type 7, 9. Vertex type triangle</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">():</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="c1"># loss = result.absmax()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>
            
            <span class="c1">#====</span>
            <span class="c1"># Check the matrices with F(\tau_i) or G(\tau_i) in the top left </span>
            <span class="c1">#====</span>

            <span class="c1"># -- Type 1, 2. Mixed type parallelogram </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">up_or_down</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">]:</span>
                        <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_Edge_Vert</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">up_or_down</span><span class="o">=</span><span class="n">up_or_down</span><span class="p">)</span>
                        <span class="c1"># loss = result.absmax()</span>
                        <span class="c1"># print(f&quot;mixed parallelogram loss for {graph_name} {obj_type} {i} is {loss}&quot;)</span>
                        <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>

            <span class="c1"># -- Type 4, 6. Edge type parallelogram</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s2">&quot;phi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s2">&quot;psi&quot;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="c1"># loss = result.absmax()</span>
                    <span class="c1"># print(f&quot;parallelogram loss for {graph_name} {obj_type} {i} is {loss}&quot;)</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values </span>
                    <span class="k">pass</span>

            <span class="c1"># -- Type 8, 10. Edge type triangle </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="c1"># loss = result.absmax()</span>
                    <span class="c1"># print(f&quot;triangle loss for {graph_name} {obj_type} {i} is {loss}&quot;)</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>

            <span class="c1"># Store the max loss for this function value </span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span>


        <span class="c1"># Get max loss over all function values</span>
        <span class="c1"># flatten the dictionary</span>
        <span class="n">loss_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">loss_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span></div>



<div class="viewcode-block" id="Assignment.all_func_vals">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.all_func_vals">[docs]</a>
    <span class="k">def</span> <span class="nf">all_func_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all the function values that are in the graphs. </span>

<span class="sd">        Returns:</span>
<span class="sd">            list : </span>
<span class="sd">                A list of all the function values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> 
        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_func_vals</span><span class="p">)</span>
        <span class="n">all_func_vals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">all_func_vals</span></div>

    
<div class="viewcode-block" id="Assignment.optimize">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Assignment.optimize">[docs]</a>
    <span class="k">def</span> <span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pulp_solver</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Uses the ILP to find the best interleaving distance bound, returns the loss value found. Further, it stores the optimal phi and psi maps which can be returned using the ``self.phi`` and ``self.psi`` attributes respectively.</span>
<span class="sd">        This function requires the `pulp` package to be installed.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            pulp_solver (pulp.LpSolver): the solver to use for the ILP optimization. If None, the default solver is used.</span>
<span class="sd">        Returns:</span>
<span class="sd">            float : </span>
<span class="sd">                The loss value found by the ILP solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">map_dict</span><span class="p">,</span> <span class="n">loss_val</span> <span class="o">=</span> <span class="n">solve_ilp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pulp_solver</span> <span class="o">=</span> <span class="n">pulp_solver</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;phi_0_V&#39;</span><span class="p">],</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;phi_0_E&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;phi_n_V&#39;</span><span class="p">],</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;phi_n_E&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;psi_0_V&#39;</span><span class="p">],</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;psi_0_E&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;psi_n_V&#39;</span><span class="p">],</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="n">map_dict</span><span class="p">[</span><span class="s1">&#39;psi_n_E&#39;</span><span class="p">]}</span>
        
        
        <span class="k">return</span> <span class="n">loss_val</span></div>
</div>

    

    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>