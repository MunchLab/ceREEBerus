

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cereeberus.distance.interleave &mdash; ceREEBerus 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ceREEBerus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Modules and Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">Tutorial Notebooks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ceREEBerus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">cereeberus.distance.interleave</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cereeberus.distance.interleave</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">cereeberus</span> <span class="kn">import</span> <span class="n">MapperGraph</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">.labeled_blocks</span> <span class="kn">import</span> <span class="n">LabeledBlockMatrix</span> <span class="k">as</span> <span class="n">LBM</span>
<span class="kn">from</span> <span class="nn">.labeled_blocks</span> <span class="kn">import</span> <span class="n">LabeledMatrix</span> <span class="k">as</span> <span class="n">LM</span>

<div class="viewcode-block" id="Interleave">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave">[docs]</a>
<span class="k">class</span> <span class="nc">Interleave</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to bound the interleaving distance between two Mapper graphs, denoted :math:`F` and :math:`G` throughout.</span>

<span class="sd">    We use keys ``[&#39;0&#39;, &#39;n&#39;, &#39;2n&#39;]`` to denote the Mapper graphs :math:`F = F_0`, :math:`F_n`, and :math:`F_{2n}` and similarly for :math:`G`.</span>

<span class="sd">    Note that the difference in the ranges of the two Mapper graphs must be within ``&#39;n&#39;``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Interleave.__init__">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> 
                        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
                        <span class="n">initialize_random_maps</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Interleave object.</span>
<span class="sd">        </span>
<span class="sd">        Parameters:</span>
<span class="sd">            F (MapperGraph):</span>
<span class="sd">                The first Mapper graph.</span>
<span class="sd">            G (MapperGraph):</span>
<span class="sd">                The second Mapper graph.</span>
<span class="sd">            n (int):</span>
<span class="sd">                The interleaving parameter. The default is 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>

        <span class="c1"># --- Check that the ranges are compatible</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">min_f</span><span class="p">()</span><span class="o">-</span><span class="n">G</span><span class="o">.</span><span class="n">min_f</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max_f</span><span class="p">()</span><span class="o">-</span><span class="n">G</span><span class="o">.</span><span class="n">max_f</span><span class="p">())</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Function values for F and G are too far apart to interleave with n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">. Try initializing with a larger n.&quot;</span><span class="p">)</span>

        <span class="c1"># ---</span>
        <span class="c1"># Containers for matrices for later </span>


        <span class="c1"># self.A = {&#39;F&#39;:{}, &#39;G&#39;:{}} # adjacency matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># boundary matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># boundary matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">D_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># distance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># induced maps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># dictionaries from function values to vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:{},</span> <span class="s1">&#39;G&#39;</span><span class="p">:{}}</span> <span class="c1"># dictionaries from function values to edges</span>

        <span class="c1"># ----</span>
        <span class="c1"># Make F graphs and smoothed versions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">I_0</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">return_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> <span class="n">I_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">return_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get the dictionaries needed for the induced maps&#39; block structure </span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">func_to_vertex_dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">func_to_edge_dict</span><span class="p">()</span>

        
        
        <span class="c1"># Make the induced map from F_0 to F_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0</span><span class="p">,</span> 
                                     <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                     <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>
        <span class="n">I_0_edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="n">I_0</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">I_0</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0_edges</span><span class="p">,</span> 
                                     <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                     <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>

        <span class="c1"># Make the induced map from F_n to F_2n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n</span><span class="p">,</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="c1"># Note that in this setting, the induced map on edges is the same as the map sending the edge to the edge with endpoints given by the vertices since there are no double edges for any smoothing &gt;= 1. </span>
        <span class="n">I_n_edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="n">I_n</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">I_n</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_edges</span><span class="p">,</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                     <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>

        <span class="c1"># ----</span>
        <span class="c1"># Now do the same for G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="n">I_0</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">return_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> <span class="n">I_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">smoothing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">return_map</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get the dictionaries needed for the induced maps&#39; block structure </span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">func_to_vertex_dict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">func_to_edge_dict</span><span class="p">()</span>

        <span class="c1"># Make the induced map from G_0 to G_n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span> <span class="n">rows_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">cols_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span> 
                                    <span class="n">map_dict</span> <span class="o">=</span> <span class="n">I_0</span><span class="p">)</span>

        <span class="c1"># self.map_dict_to_matrix(I_0, </span>
        <span class="c1">#                         self.val_to_verts[&#39;G&#39;][&#39;n&#39;], </span>
        <span class="c1">#                         self.val_to_verts[&#39;G&#39;][&#39;0&#39;])</span>
        <span class="n">I_0_edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="n">I_0</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">I_0</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_0_edges</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">])</span>

        <span class="c1"># Make the induced map from G_n to G_2n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">I_n_edges</span> <span class="o">=</span> <span class="p">{(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="n">I_n</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">I_n</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">edges</span><span class="p">()}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="n">I_n_edges</span><span class="p">,</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        
        <span class="c1"># End making smoothings and induced maps</span>
        <span class="c1"># ----</span>
        <span class="c1"># ---</span>
        <span class="c1"># Build boundary matrices </span>

        <span class="k">for</span> <span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>

                <span class="n">B_down</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>
                <span class="n">B_up</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]:</span>
                        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">verts_down</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">verts_up</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">B_down</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">verts_down</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>
                        <span class="n">B_up</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">verts_up</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">edges</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                            <span class="n">B_down</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">B_up</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="n">min_i</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
                <span class="n">max_i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

                <span class="n">min_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">min_i</span><span class="p">]</span>
                <span class="n">max_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">max_i</span><span class="p">]</span>

                <span class="n">B_up</span><span class="p">[</span><span class="n">min_i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">min_verts</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[])</span>
                <span class="n">B_down</span><span class="p">[</span><span class="n">max_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span><span class="n">rows</span> <span class="o">=</span> <span class="n">max_verts</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_down</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph_name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">B_up</span>

                

        <span class="c1"># for key in [&#39;0&#39;, &#39;n&#39;, &#39;2n&#39;]:</span>

        <span class="c1">#     rows = self.G(key).sorted_vertices()</span>
        <span class="c1">#     cols = self.G(key).sorted_edges()</span>

        <span class="c1">#     self.B_[&#39;G&#39;][key] = LM(rows = rows, cols = cols)</span>
        <span class="c1">#     for e in cols:</span>
        <span class="c1">#         self.B_[&#39;G&#39;][key][e[0], e] = 1</span>
        <span class="c1">#         self.B_[&#39;G&#39;][key][e[1], e] = 1</span>

        <span class="c1"># End boundary matrices</span>
        <span class="c1"># ---</span>

        <span class="c1"># ---</span>
        <span class="c1"># Build the distance matrices </span>
        <span class="c1"># Note.... I don&#39;t think I actually need all of these, but I&#39;m going to build them all anyway.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">metagraph</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">,</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">,</span><span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>

                <span class="c1"># Vertex version </span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">metagraph</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

                <span class="n">val_to_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

                <span class="n">block_D</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">f_i</span> <span class="ow">in</span> <span class="n">val_to_verts</span><span class="p">:</span>
                    <span class="n">vert_set</span> <span class="o">=</span> <span class="n">val_to_verts</span><span class="p">[</span><span class="n">f_i</span><span class="p">]</span>
                    <span class="n">D_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_set</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">vert_set</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vert_set</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vert_set</span><span class="p">)):</span>
                            <span class="n">D_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">thickening_distance</span><span class="p">(</span><span class="n">vert_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vert_set</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">D_i</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">block_D</span><span class="p">[</span><span class="n">f_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span> <span class="n">rows</span> <span class="o">=</span>  <span class="n">vert_set</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span>  <span class="n">vert_set</span><span class="p">,</span><span class="n">array</span> <span class="o">=</span>  <span class="n">D_i</span><span class="p">)</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_D</span>

                <span class="c1"># Edge version </span>
                <span class="c1"># Note that in this setting, the distance between two edges is the max distance between any pair of vertices in the two edges.</span>
                <span class="n">val_to_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>

                <span class="n">block_D</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">f_i</span> <span class="ow">in</span> <span class="n">val_to_edges</span><span class="p">:</span>
                    <span class="n">edge_set</span> <span class="o">=</span> <span class="n">val_to_edges</span><span class="p">[</span><span class="n">f_i</span><span class="p">]</span>
                    <span class="n">D_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_set</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_set</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edge_set</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_set</span><span class="p">)):</span>
                            <span class="n">u_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">edge_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">u_j</span><span class="p">,</span> <span class="n">v_j</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">edge_set</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                            <span class="c1"># Lower vertex checking for u_i and u_v</span>
                            <span class="n">D_lower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">f_i</span><span class="p">]</span>
                            <span class="n">u_i_index</span> <span class="o">=</span> <span class="n">D_lower</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u_i</span><span class="p">)</span>
                            <span class="n">u_j_index</span> <span class="o">=</span> <span class="n">D_lower</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u_j</span><span class="p">)</span>
                            <span class="n">lower_k</span> <span class="o">=</span> <span class="n">D_lower</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">u_i_index</span><span class="p">,</span> <span class="n">u_j_index</span><span class="p">]</span>

                            <span class="c1"># Upper vertex checking </span>
                            <span class="n">D_upper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">f_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">v_i_index</span> <span class="o">=</span> <span class="n">D_upper</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v_i</span><span class="p">)</span>
                            <span class="n">v_j_index</span> <span class="o">=</span> <span class="n">D_upper</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v_j</span><span class="p">)</span>
                            <span class="n">upper_k</span> <span class="o">=</span> <span class="n">D_upper</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">v_i_index</span><span class="p">,</span> <span class="n">v_j_index</span><span class="p">]</span>

                            <span class="c1"># Distance for the edge is the largest k so that both endpoints have mapped to the same thing. </span>
                            <span class="n">D_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">lower_k</span><span class="p">,</span> <span class="n">upper_k</span><span class="p">)</span>
                            <span class="n">D_i</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D_i</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">block_D</span><span class="p">[</span><span class="n">f_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LM</span><span class="p">(</span> <span class="n">rows</span> <span class="o">=</span>  <span class="n">edge_set</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span>  <span class="n">edge_set</span><span class="p">,</span><span class="n">array</span> <span class="o">=</span>  <span class="n">D_i</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_D</span>



        <span class="c1"># ----</span>
        <span class="c1"># phi: F -&gt; G^n</span>

        <span class="c1"># Initialize the phi matrices. These will have all 0 entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:{},</span> <span class="s1">&#39;n&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="c1"># End phi</span>
        <span class="c1"># ---</span>



        <span class="c1"># ----</span>
        <span class="c1"># psi: G -&gt; F^n</span>
        
        <span class="c1"># Initialize the psi matrices. These will have all 0 entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:{},</span> <span class="s1">&#39;n&#39;</span><span class="p">:{}}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;V&#39;</span><span class="p">:{},</span> <span class="s1">&#39;E&#39;</span><span class="p">:{}}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">initialize_random_maps</span><span class="p">)</span></div>

        

        <span class="c1"># End psi</span>
        <span class="c1"># ---</span>

    <span class="c1">### ----------------</span>
    <span class="c1"># Functions for getting stuff out of all the dictionaries </span>
    <span class="c1">### ----------------</span>

<div class="viewcode-block" id="Interleave.F">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.F">[docs]</a>
    <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the MapperGraph for :math:`F` with key.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) :</span>
<span class="sd">                The key for the MapperGraph. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``. Default is ``&#39;0&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">F_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    
<div class="viewcode-block" id="Interleave.G">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.G">[docs]</a>
    <span class="k">def</span> <span class="nf">G</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the MapperGraph for :math:`G` with key.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the MapperGraph. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``. Default is ``&#39;0&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.B">[docs]</a>
    <span class="k">def</span> <span class="nf">B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is an endpoint of edge :math:`e` and 0 otherwise.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_labeled_matrix</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_labeled_matrix</span><span class="p">()</span></div>


<div class="viewcode-block" id="Interleave.B_down">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.B_down">[docs]</a>
    <span class="k">def</span> <span class="nf">B_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the downward boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is a *lower* endpoint of edge :math:`e` and 0 otherwise.</span>


<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.B_up">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.B_up">[docs]</a>
    <span class="k">def</span> <span class="nf">B_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the upward boundary matrix for a Mapper graph. This is the matrix with entry :math:`B[v,e]` equal to 1 if vertex :math:`v` is an *upper* endpoint of edge :math:`e` and 0 otherwise.</span>

<span class="sd">        Warning: This is stored as a block matrix but we need to be careful when multiplying due to the index shift! TODO TODO TODO </span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.I">[docs]</a>
    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the induced map from one Mapper graph to another, specifically from ``graph_key`` to ``graph_(key+n)`` sending ``obj_type`` to the same type. For example, ``I(&#39;G&#39;, &#39;n&#39;, &#39;E&#39;)`` is the map for edges from :math:`G_n` to :math:`G_{2n}`.</span>
<span class="sd">        </span>
<span class="sd">        This is the matrix with entry :math:`I[u, v] = 1` if vertex :math:`v` in the first graph maps to vertex :math:`u` in the second graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the induced map for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the induced map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">I_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>

        

<div class="viewcode-block" id="Interleave.D">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.D">[docs]</a>
    <span class="k">def</span> <span class="nf">D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the distance matrix for a Mapper graph. This is the matrix with entry :math:`D[u, v]` equal to the minimum thickening needed for vertices :math:`u` and :math:`v` to map to the same connected component (similarly for edges). Note this distance is only defined for vertices or edges at the same function value. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to get the distance matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the distance matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">D_</span><span class="p">[</span><span class="n">graph</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.phi">[docs]</a>
    <span class="k">def</span> <span class="nf">phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`F \\to G^n`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.psi">[docs]</a>
    <span class="k">def</span> <span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the interleaving map :math:`\\psi: G  \\to F^n` on either vertices or edges.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span></div>


<div class="viewcode-block" id="Interleave.get_interleaving_map">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.get_interleaving_map">[docs]</a>
    <span class="k">def</span> <span class="nf">get_interleaving_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the relevant interleaving map. Helpful for iterating over options. </span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either ``&#39;phi&#39;`` or ``&#39;psi&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LabeledBlockMatrix : </span>
<span class="sd">                The relevant interleaving map.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown maptype </span><span class="si">{</span><span class="n">maptype</span><span class="si">}</span><span class="s2">. Must be &#39;phi&#39; or &#39;psi&#39;.&quot;</span><span class="p">)</span></div>


    <span class="c1">### ----------------</span>
    <span class="c1">#</span>
    <span class="c1">### ----------------</span>
    
    
<div class="viewcode-block" id="Interleave.set_random_assignment">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.set_random_assignment">[docs]</a>
    <span class="k">def</span> <span class="nf">set_random_assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_n</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the phi and psi matrices to random values. No matter what, the maps from F to Gn and G to Fn will be randomly set.  If ``&#39;random_n&#39;`` is True, the maps from Fn to G2n and Gn to F2n will also be randomly set. Otherwise, we will use matrix tricks to figure out the later from the former. </span>

<span class="sd">        Note this functions assumes the phi and psi dictionaries were set on initialization. It will overwrite any contents that are there. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ----</span>
        <span class="c1"># phi: F -&gt; G^n</span>

        <span class="c1"># Set the phi matrices. These will have all random entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">random_n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">to_indicator</span><span class="p">()</span>

        <span class="c1"># End phi</span>
        <span class="c1"># ---</span>

        <span class="c1"># ----</span>
        <span class="c1"># psi: G -&gt; F^n</span>

        <span class="c1"># Set the psi matrices. These will have all random entries.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;0&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">random_n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;V&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span> 
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_verts</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">LBM</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">][</span><span class="s1">&#39;2n&#39;</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">val_to_edges</span><span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">][</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
                                    <span class="n">random_initialize</span> <span class="o">=</span> <span class="n">random_n</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">obj_type</span><span class="p">]</span><span class="o">.</span><span class="n">to_indicator</span><span class="p">()</span></div>


        <span class="c1"># End psi</span>
        <span class="c1"># ---</span>


    <span class="c1">### ----------------</span>
    <span class="c1"># Functions for drawing stuff</span>
    <span class="c1">### ----------------</span>

<div class="viewcode-block" id="Interleave.draw_all_graphs">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_graphs">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sharey</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_0$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_n$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">(</span><span class="s1">&#39;2n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$F_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_0$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_n$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">(</span><span class="s1">&#39;2n&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$G_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.draw_I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_I">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_I</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the induced map from one Mapper graph to another.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the induced map for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the induced map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_n&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_2n&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Interleave.draw_all_I">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_I">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_I</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the induced maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">.4</span><span class="p">,</span> <span class="n">hspace</span><span class="o">=</span><span class="mf">.4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Vertices: $G_0 \to G_</span><span class="si">{n}</span><span class="s1">$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Edges: $G_0 \to G_</span><span class="si">{n}</span><span class="s1">$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Vertices: $G_n \to G_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_I</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Edges: $G_n \to G_</span><span class="si">{2n}</span><span class="s1">$&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.draw_B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_B">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the boundary matrix for a Mapper graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the boundary matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the boundary matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;B(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;E(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Interleave.draw_all_B">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_B">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_B</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">18</span><span class="p">),</span> <span class="n">spacing</span> <span class="o">=</span> <span class="p">(</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the boundary matrices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(F_0)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(F_n)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(F_</span><span class="si">{2n}</span><span class="s1">)$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(G_0)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(G_n)$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_B</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$B(G_</span><span class="si">{2n}</span><span class="s1">)$&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.draw_D">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_D">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                    <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the distance matrix for a Mapper graph.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            graph (str) : </span>
<span class="sd">                The graph to draw the distance matrix for. Either ``&#39;F&#39;`` or ``&#39;G&#39;``.</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the distance matrix. Either ``&#39;0&#39;``, ``&#39;n&#39;``, or ``&#39;2n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of matrix. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            colorbar (bool) : </span>
<span class="sd">                Whether to draw a colorbar. Default is True.</span>
<span class="sd">            ax ( matplotlib.axes.Axes) :</span>
<span class="sd">                The axes to draw the matrix on. If None, the current axes will be used.</span>
<span class="sd">            **kwargs (dict) : </span>
<span class="sd">                Additional keyword arguments to pass to the drawing function.</span>

<span class="sd">        Returns:</span>
<span class="sd">            matplotlib.axes.Axes</span>
<span class="sd">                The axes the matrix was drawn on.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="n">colorbar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;V(</span><span class="si">{</span><span class="n">graph</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Interleave.draw_phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_phi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the map :math:`\\psi: F \\to G^n`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        
        <span class="bp">self</span><span class="o">.</span><span class="n">phi</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_2n&#39;</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">(G</span><span class="si">{</span><span class="n">F_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">(F</span><span class="si">{</span><span class="n">G_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>

    
<div class="viewcode-block" id="Interleave.draw_psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_psi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw the map :math:`\\psi: G \\to F^n`.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            key (str) : </span>
<span class="sd">                The key for the map. Either ``&#39;0&#39;`` or ``&#39;n&#39;``.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of map. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">F_key</span> <span class="o">=</span> <span class="s1">&#39;_n&#39;</span>
            <span class="n">G_key</span> <span class="o">=</span> <span class="s1">&#39;_2n&#39;</span>
            
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">(G</span><span class="si">{</span><span class="n">G_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">(F</span><span class="si">{</span><span class="n">F_key</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Interleave.draw_all_phi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_phi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_phi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">spacing</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.5</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the ``phi`` maps.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_0^V$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_n^V$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_0^E$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_phi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\varphi_n^E$&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.draw_all_psi">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.draw_all_psi">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_all_psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span> <span class="n">spacing</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">.5</span><span class="p">),</span>     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw all the ``psi`` maps.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">figsize</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hspace</span><span class="o">=</span><span class="n">spacing</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_0^V$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_n^V$&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_0^E$&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_psi</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>  <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\psi_n^E$&#39;</span><span class="p">)</span></div>


    <span class="c1"># ==========</span>
    <span class="c1"># Functions for checking commutative diagrams </span>

<div class="viewcode-block" id="Interleave.parallelogram_Edge_Vert">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.parallelogram_Edge_Vert">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram_Edge_Vert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">returntype</span> <span class="o">=</span> <span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">up_or_down</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span><span class="p">,</span>
                                    <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>  
                                    <span class="n">drawtype</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> 
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check that the parallelogram for the pair :math:`(U_{\\tau_I}\\subset U_{\\sigma_i})` commutes.</span>
<span class="sd">        This is the one that relates the edge maps to the vertex maps.</span>
<span class="sd">        (These are types 1 (when maptype = &#39;phi&#39;) and 2 (when maptype = &#39;psi&#39;) from Liz&#39;s Big List )</span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value. Because a function value has both an up and down version, we need to specify which one we want to check with the ``up_or_down`` parameter.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either ``&#39;phi&#39;`` or ``&#39;psi&#39;``.</span>
<span class="sd">            returntype (str) : </span>
<span class="sd">                The type of return. Either ``&#39;dist&#39;`` if you want the matrix that gives the thickening required to make the diagram commute; or ``&#39;commute&#39;`` to just give the map mismatch.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            up_or_down (str) :</span>
<span class="sd">                Whether to check the up or down version of the parallelogram. Either ``&#39;up&#39;`` or ``&#39;down&#39;``. Default is ``&#39;down&#39;``.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is ``False``.</span>
<span class="sd">            drawtype (str) : </span>
<span class="sd">                The type of drawing. Either ``&#39;all&#39;`` or ``&#39;result&#39;``. Default is ``&#39;all&#39;``.</span>
<span class="sd">            **kwargs : </span>
<span class="sd">                Additional keyword arguments to pass to the drawing function.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickenin grequired to make the diagram commute if returntype is ``&#39;dist&#39;``; or the map mismatch if returntype is ``&#39;commute&#39;``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span>

            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)</span> 
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>

            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span> <span class="c1"># tau_i \to \sigma_i</span>
                <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_down</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
                <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>
            <span class="k">elif</span> <span class="n">up_or_down</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span> <span class="c1"># \tau_i \to \sigma_{i+1}</span>
                <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B_up</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
                <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
                <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">)[</span><span class="n">func_val</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown up_or_down </span><span class="si">{</span><span class="n">up_or_down</span><span class="si">}</span><span class="s2">. Must be &#39;up&#39; or &#39;down&#39;.&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Top</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Top_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">0,V</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot B_</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Top_title</span><span class="p">)</span>

            <span class="n">Bottom</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Bottom_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$B_</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot </span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">0,E</span><span class="se">}}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Bottom_title</span><span class="p">)</span>

            <span class="n">Result</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">Result_title</span> <span class="o">=</span> <span class="n">Top_title</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">Bottom_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_title</span><span class="p">)</span>

            <span class="n">Result_Dist</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
            <span class="n">Result_Dist_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">,n,V</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot (</span><span class="si">{</span><span class="n">Result_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_Dist_title</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;result&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Result_Dist</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parallelogram for $</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">$ (Edge-Vertex)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;dist&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result_Dist</span>
        <span class="k">elif</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;commute&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown returntype </span><span class="si">{</span><span class="n">returntype</span><span class="si">}</span><span class="s2">. Must be &#39;dist&#39; or &#39;commute&#39;.&quot;</span><span class="p">)</span></div>


    <span class="c1">#---</span>

<div class="viewcode-block" id="Interleave.parallelogram">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.parallelogram">[docs]</a>
    <span class="k">def</span> <span class="nf">parallelogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maptype</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                            <span class="n">returntype</span> <span class="o">=</span> <span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                            <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                            <span class="n">drawtype</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">                            </span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the paralellograms for checking that it&#39;s a nat trans.</span>
<span class="sd">        These are types 3-6 from Liz&#39;s Big List. </span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            maptype (str) : </span>
<span class="sd">                The type of map. Either &#39;phi&#39; or &#39;psi&#39;.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of object. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            returntype (str) : </span>
<span class="sd">                The type of return. Either ``&#39;dist&#39;`` if you want the matrix that gives the thickenin grequired to make the diagram commute; or ``&#39;commute&#39;`` to just give the map mismatch.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is False.</span>
<span class="sd">            drawtype (str) : </span>
<span class="sd">                The type of drawing. Either &#39;all&#39; or &#39;result&#39;. Default is &#39;all&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickening required to make the diagram commute if returntype is ``&#39;dist&#39;``; or the map mismatch if returntype is ``&#39;commute&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;phi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\varphi&#39;</span>
        <span class="k">elif</span> <span class="n">maptype</span> <span class="o">==</span> <span class="s1">&#39;psi&#39;</span><span class="p">:</span>
            <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">maptype_latex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\psi&#39;</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Do this for a single input function value</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>
            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">end_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>

        <span class="c1"># --- Drawing--- #</span>
        <span class="k">if</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Top</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Top_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot I_</span><span class="se">{{</span><span class="s2">0,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Top_title</span><span class="p">)</span>

            <span class="n">Bottom</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Bottom_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$I_</span><span class="se">{{</span><span class="s2">n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot </span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">0,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Bottom_title</span><span class="p">)</span>

            <span class="n">Result</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">Result_title</span> <span class="o">=</span> <span class="n">Top_title</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">Bottom_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_title</span><span class="p">)</span>

            <span class="n">Result_Dist</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
            <span class="n">Result_dist_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">end_graph</span><span class="si">}</span><span class="s2">,2n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot (</span><span class="si">{</span><span class="n">Result_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_dist_title</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;result&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Result_Dist</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parallelogram for $</span><span class="si">{</span><span class="n">maptype_latex</span><span class="si">}</span><span class="s2">$ (Edge-Vertex)&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;dist&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result_Dist</span>
        <span class="k">elif</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;commute&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown returntype </span><span class="si">{</span><span class="n">returntype</span><span class="si">}</span><span class="s2">. Must be &#39;dist&#39; or &#39;commute&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.triangle">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.triangle">[docs]</a>
    <span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> 
                        <span class="n">returntype</span> <span class="o">=</span> <span class="s1">&#39;dist&#39;</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                        <span class="n">draw</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">drawtype</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the triangle for checking that it&#39;s an interleaving. </span>

<span class="sd">        If ``func_val`` is not None, we will only check the parallelogram for that function value.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            start_graph (str) : </span>
<span class="sd">                The starting graph. Either &#39;F&#39; or &#39;G&#39;.</span>
<span class="sd">            obj_type (str) : </span>
<span class="sd">                The type of object. Either ``&#39;V&#39;`` or ``&#39;E&#39;``.</span>
<span class="sd">            returntype (str) : </span>
<span class="sd">                The type of return. Either ``&#39;dist&#39;`` if you want the matrix that gives the thickenin grequired to make the diagram commute; or ``&#39;commute&#39;`` to just give the map mismatch.</span>
<span class="sd">            func_val (int) :</span>
<span class="sd">                The function value to check the parallelogram for. If None, we will check all function values for the full matrix.</span>
<span class="sd">            draw (bool) : </span>
<span class="sd">                Whether to draw the maps. Default is False.</span>
<span class="sd">            drawtype (str) : </span>
<span class="sd">                The type of drawing. Either &#39;all&#39; or &#39;result&#39;. Default is &#39;all&#39;.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            LabeledMatrix : </span>
<span class="sd">                The matrix that gives the thickenin grequired to make the diagram commute if returntype is ``&#39;dist&#39;``; or the map mismatch if returntype is ``&#39;commute&#39;``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start_graph</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;G&#39;</span>
            <span class="n">map1</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span>
            <span class="n">map2</span> <span class="o">=</span> <span class="s1">&#39;psi&#39;</span>
        <span class="k">elif</span> <span class="n">start_graph</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
            <span class="n">end_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span>
            <span class="n">map1</span> <span class="o">=</span> <span class="s1">&#39;psi&#39;</span>
            <span class="n">map2</span> <span class="o">=</span> <span class="s1">&#39;phi&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown start_graph </span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">. Must be &#39;F&#39; or &#39;G&#39;.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>

            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)</span> <span class="o">@</span> <span class="n">Result</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map2</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interleaving_map</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">map1</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Top</span> <span class="o">-</span> <span class="n">Bottom</span>

            <span class="n">Result_Dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">D</span><span class="p">(</span><span class="n">start_graph</span><span class="p">,</span> <span class="s1">&#39;2n&#39;</span><span class="p">,</span> <span class="n">obj_type</span><span class="p">)[</span><span class="n">func_val</span><span class="p">]</span> <span class="o">@</span> <span class="n">Result</span>

        <span class="k">if</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Top</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Top_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$I_</span><span class="se">{{</span><span class="s2">0,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot I_</span><span class="se">{{</span><span class="s2">n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Top_title</span><span class="p">)</span>

            <span class="n">Bottom</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Bottom_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$I_</span><span class="se">{{</span><span class="s2">n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot I_</span><span class="se">{{</span><span class="s2">2n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2">$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Bottom_title</span><span class="p">)</span>

            <span class="n">Result</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">Result_title</span> <span class="o">=</span> <span class="n">Top_title</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">Bottom_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_title</span><span class="p">)</span>

            <span class="n">Result_Dist</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;PuOr&#39;</span><span class="p">)</span>
            <span class="n">Result_dist_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;$D_</span><span class="se">{{</span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2">,2n,</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="se">}}</span><span class="s2"> </span><span class="se">\\</span><span class="s2">cdot (</span><span class="si">{</span><span class="n">Result_title</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)$&quot;</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">Result_dist_title</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">draw</span> <span class="ow">and</span> <span class="n">drawtype</span> <span class="o">==</span> <span class="s1">&#39;result&#39;</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
            <span class="n">Result</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Triangle for </span><span class="si">{</span><span class="n">start_graph</span><span class="si">}</span><span class="s2"> (Edge-Vertex)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;dist&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result_Dist</span>
        <span class="k">elif</span> <span class="n">returntype</span> <span class="o">==</span> <span class="s1">&#39;commute&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown returntype </span><span class="si">{</span><span class="n">returntype</span><span class="si">}</span><span class="s2">. Must be &#39;dist&#39; or &#39;commute&#39;.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.loss">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.loss">[docs]</a>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the actual loss :math:`k` for the interleaving distance. This means that there is an :math:`(n+k)`-interleaving. </span>

<span class="sd">        Returns:</span>
<span class="sd">            float : </span>
<span class="sd">                The loss value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># All the edge-vertex parallelogram maps </span>
        <span class="k">for</span> <span class="n">maptype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_Edge_Vert</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
            <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

        <span class="c1"># All the parallelogram maps </span>
        <span class="k">for</span> <span class="n">maptype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

        <span class="c1"># ALl the triangle maps</span>
        <span class="k">for</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">drawtype</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;result&#39;</span><span class="p">]:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">)</span>
                <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interleave.loss_by_block">
<a class="viewcode-back" href="../../../modules/distance/interleave.html#cereeberus.distance.interleave.Interleave.loss_by_block">[docs]</a>
    <span class="k">def</span> <span class="nf">loss_by_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the loss for each block of the interleaving distance. </span>

<span class="sd">        Returns:</span>
<span class="sd">            dict : </span>
<span class="sd">                A dictionary with the loss for each block.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This is not at all done yet, consider this a placeholder!</span>
        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">())</span> 
        <span class="n">all_func_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_func_vals</span><span class="p">)</span>
        <span class="n">all_func_vals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">loss_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">all_func_vals</span><span class="p">:</span>
            <span class="c1">#====</span>
            <span class="c1"># Check the matrices with F(\sigma_i) or G(\sigma_i) in the top left </span>
            <span class="c1">#====</span>
            <span class="n">loss_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># -- Type 3, 5. Vertex type parallelogram </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">():</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span> 

            <span class="c1"># -- Type 7, 9. Vertex type triangle</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;V&#39;</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">():</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>
            
            <span class="c1">#====</span>
            <span class="c1"># Check the matrices with F(\tau_i) or G(\tau_i) in the top left </span>
            <span class="c1">#====</span>

            <span class="c1"># -- Type 1, 2. Mixed type parallelogram </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram_Edge_Vert</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>

            <span class="c1"># -- Type 4, 6. Edge type parallelogram</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">maptype</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s2">&quot;phi&quot;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s2">&quot;psi&quot;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallelogram</span><span class="p">(</span><span class="n">maptype</span> <span class="o">=</span> <span class="n">maptype</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values </span>
                    <span class="k">pass</span>

            <span class="c1"># -- Type 8, 10. Edge type triangle </span>
            <span class="k">for</span> <span class="p">(</span><span class="n">Graph</span><span class="p">,</span> <span class="n">graph_name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)]:</span>
                <span class="n">obj_type</span> <span class="o">=</span> <span class="s1">&#39;E&#39;</span>
                <span class="n">edge_vals</span> <span class="o">=</span> <span class="n">Graph</span><span class="p">()</span><span class="o">.</span><span class="n">get_function_values</span><span class="p">()</span>
                <span class="n">edge_vals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edge_vals</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">edge_vals</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">edge_vals</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangle</span><span class="p">(</span><span class="n">start_graph</span> <span class="o">=</span> <span class="n">graph_name</span><span class="p">,</span> <span class="n">obj_type</span> <span class="o">=</span> <span class="n">obj_type</span><span class="p">,</span> <span class="n">func_val</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">loss</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">absmax</span><span class="p">()</span>
                    <span class="n">loss_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># This catch is because the two graphs might have different ranges of function values</span>
                    <span class="k">pass</span>

            <span class="c1"># Store the max loss for this function value </span>
            <span class="n">loss_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span>


        <span class="c1"># Get max loss over all function values</span>
        <span class="c1"># flatten the dictionary</span>
        <span class="n">loss_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">loss_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">loss_list</span><span class="p">)</span></div>
</div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>